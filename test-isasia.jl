# Base code author: Luis Badesa
#
# This code is a simple example of an Economic Dispatch optimization,
# intended to teach how to create a simple optimization problem in JuMP.

##############

## Install JuMP 
# (UNCOMMENT the next block of code if JuMP is not installed)
#= 
    import Pkg
    Pkg.add("JuMP") 
=# 
using JuMP

## Choose an optimization solver 
# (UNCOMMENT the next block of code if the Julia package for the solver is not installed)
#= 
    Pkg.add("HiGHS") 
=# 
using HiGHS

##############
input_data = 1
## Input Data
if input_data == 1
    cost = [5  10  15
            5   0   0] # €/MWh

    Pₘₐₓ = [20  20  20 
            20   0   0] # Rated power of each generator, MW

    Demand = [50.0   5.0] # MW

    P_max_line = [0  5 
                  5  0] # Max power per line
elseif input_data == 2
    cost = [5  10  15
            5   0   0] # €/MWh

    Pₘₐₓ = [20  20  20 
            20   0   0] # Rated power of each generator, MW

    Demand = [50.0   5.0] # MW

    P_max_line = [0  15 
                  15  0] # Max power per line
elseif input_data == 3
    cost = [5.0  7.2  0.0
            5.5  8.0  0.0] # €/MWh

    Pₘₐₓ = [400  800   0 
            200  400   0] # Rated power of each generator, MW

    Demand = [500.00   400.0] # MW

    P_max_line = [0    1000 
                  1000    0] # Max power per line
end

N_nodes = size(cost, 1) # Number of generators
N_GxN =   size(cost, 2) # Number of generators per node

#############
## Create the model for the optimization
model = Model(HiGHS.Optimizer)
set_silent(model) 

# Define Decision Variables for power generated by each unit:
@variable(model,                   0 <=    P[ii in 1:N_nodes, jj in 1:N_GxN]   <= Pₘₐₓ[ii, jj])       # MW
@variable(model, -P_max_line[ii, jj] <= Pₗᵢₙₑ[ii in 1:N_nodes, jj in 1:N_nodes] <= P_max_line[ii, jj]) # MW


#       ***** Define the constraints *****

# Total generated power
#@constraint(model, sum(P) == sum(Demand))  # Total power output equals demand / Por que al descomentar esta linea de jode el precio marginal
@constraint(model, sum(Pₗᵢₙₑ) == 0)
# Local power balance
power_balance = []
for ii in 1:N_nodes
    local_power_balance = @constraint(model, sum(P[ii, :]) == sum(Pₗᵢₙₑ[ii, :]) + Demand[ii])
    push!(power_balance, local_power_balance)
end

#       ***** Define the objective function *****
Total_cost = sum(cost .* P)

@objective(model, Min, Total_cost)

print(model)
println()

##############

## Solve the optimization problem
optimize!(model)

##############

## Get the solution
println()
println("##########################################")
println()
println("SOLUTION:")
println()

# Check optimization status
status = JuMP.termination_status(model)
if status == MOI.OPTIMAL
    ## Get the solution
    println("Total cost: ", objective_value(model), " €")
else
    println("The model did not solve to optimality. Please check the constraints and data.")
end


println()

println("Power output:")
for ii in 1:N_nodes, jj in 1:N_GxN
    if value(P[ii,jj]) != 0
        println("  - Node $ii Generator $jj: ", value(P[ii,jj]), " MW")
    end
end
println()

println("Power Flow:")
for ii in 1:N_nodes, jj in 1:N_nodes
    if value(Pₗᵢₙₑ[ii,jj]) != 0 && ii != jj
        println("  - Line from $ii to $jj: ", value(Pₗᵢₙₑ[ii,jj]), " MW")
    end
end
println()

println("Marginal price:")
for ii in 1:N_nodes
    λₑₙₑᵣ = dual(power_balance[ii]) # Marginal price of energy, €/MWh
    println("Price of energy node $ii: ", λₑₙₑᵣ, " €/MWh")
end